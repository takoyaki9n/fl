関数・論理型プログラミング演習第1回レポート
氏名:八尋渉
学籍番号:05-141032

問1
ソースコード: q2_1.ml
実行例: test_q2_1.mlを参照
考察:
演算は、基本的に引数の一方をパターンマッチングで引数の片方分解してデクリメントし、もう一方に操作を加える。
Scc n = n + 1,Pred n = n - 1とすると、
add n1 n2 = add (Scc n1) (Pred n2) 
sub n1 n2 = sub (Pred n1) (Pred n2)
mul n1 n2 = n1 + (mul n1 (Pred n2))
pow n1 n2 = n2 * (pow n1 (Pred n2))
という関係を利用している。
n2iとi2nも基本的には1ずつ足しながら再帰的に計算する。
i2n n = 1 + (i2n (Pred n))
n2i i = Scc (n2i (i - 1))

問2
ソースコード: q2_2.ml
実行例: test_q2_2.mlを参照
考察:
add、sub、mulは2進数の筆算をイメージして、パターンマッチングで下一桁づつ分解しながら行なっている。
add、subの繰り上がり/下がりは次の桁の引数に直接繰り上がり/下がりを次の桁の引数に足し引きしている。
mulは、1桁ずつ左シフトしながら足しあわせてゆく。
powは2つもしくは3つに分解しながら行う。
pow n1 2*n2 = mul (pow n1 n2) (pow n1 n2)
pow n1 2*n2+1 = mul (mul n1 (pow n1 n2)) (pow n1 n2)

問3
ソースコード: q2_3.ml
実行例: test_q2_3.mlを参照
考察:
特記すべきことはあまりないが、@演算を使わないために、まずは逆順でリストをつくってから逆転させる。

問4
ソースコード: q2_4.ml
実行例: test_q2_4.mlを参照
考察:
リストをキューっぽく使うために@を使ってenqueueのような操作をしているので、若干無駄があるかもしれないが、面倒なのでこれで良いとする。

問5・6
ソースコード: q2_5.ml, q2_6.ml
実行例: test_q2_6.mlを参照
考察:
与えられた抽象構文木をひたすら分解して評価してゆく。
引数の型がおかしければ例外を投げる。

発展1
ソースコード: e2_1.ml
実行例: test_e2_1.mlを参照
考察:
church数は、与えられた関数を何回合成するかで数を定義する。
addは、「fにn2回適用した返り値にn1回適用」
mulは、「fをn2回合成した関数をn1回合成」
powは、「n2回の合成をn1回する」
という考え方で実装した。
subは、「c1にn2回分predを適用」という考え方で実装したが、predの定義は、wikipedia英語版にあったものを使った。


発展2(未着手)
ソースコード: e2_2.ml
実行例: test_e2_2.mlを参照
考察:


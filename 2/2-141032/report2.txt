関数・論理型プログラミング演習第1回レポート
氏名:八尋渉
学籍番号:05-141032

問1
ソースコード: q2_1.ml
実行例: test_q2_1.mlを参照
考察:
演算は、基本的に引数の一方をパターンマッチングで引数の片方分解してデクリメントし、もう一方に操作を加える。
Scc n = n + 1,Pred n = n - 1とすると、
add n1 n2 = add (Scc n1) (Pred n2) 
sub n1 n2 = sub (Pred n1) (Pred n2)
mul n1 n2 = n1 + (mul n1 (Pred n2))
pow n1 n2 = n2 * (pow n1 (Pred n2))
という関係を利用している。
n2iとi2nも基本的には1ずつ足しながら再帰的に計算する。
i2n n = 1 + (i2n (Pred n))
n2i i = Scc (n2i (i - 1))

問2
ソースコード: q2_2.ml
実行例: test_q2_2.mlを参照
考察:
add、sub、mulは2進数の筆算をイメージして、パターンマッチングで下一桁づつ分解しながら行なっている。
add、subの繰り上がり/下がりは次の桁の引数に直接繰り上がり/下がりを次の桁の引数に足し引きしている。
mulは、1桁ずつ左シフトしながら足しあわせてゆく。
powは2つもしくは3つに分解しながら行う。
pow n1 2*n2 = mul (pow n1 n2) (pow n1 n2)
pow n1 2*n2+1 = mul (mul n1 (pow n1 n2)) (pow n1 n2)

問3
ソースコード: q2_3.ml
実行例: test_q2_3.mlを参照
考察:
特記すべきことはあまりないが、@演算を使わないために、まずは逆順でリストをつくってから逆転させる。

問4
ソースコード: q2_4.ml
実行例: test_q2_4.mlを参照
考察:
リストをキューっぽく使うために@を使ってenqueueのような操作をしているので、若干無駄があるかもしれないが、面倒なのでこれで良いとする。

問5・6
ソースコード: q2_5.ml, q2_6.ml
実行例: test_q2_6.mlを参照
考察:
与えられた抽象構文木をひたすら分解して評価してゆく。
引数の型がおかしければ例外を投げる。

発展1
ソースコード: e2_1.ml
実行例: test_e2_1.mlを参照
考察:
church数は、与えられた関数を何回合成するかで数を定義する。
addは、「fにn2回適用した返り値にn1回適用」
mulは、「fをn2回合成した関数をn1回合成」
powは、「n2回の合成をn1回する」
という考え方で実装した。
subは、「c1にn2回分predを適用」という考え方で実装したが、predの定義は、wikipedia英語版にあったものを使った。

発展2
ソースコード: e2_2.ml
実行例: test_e2_2.mlを参照(#useしてるだけ)
考察:
カリー・ハワード同型対応は、形式論理の証明と(型つき)ラムダ計算が1対1に対応するという関係のことである。
とくに、単純型付きラムダ計算は、直感主義論理と対応している。
単純型付きラムダ計算においては不動点コンビネータが定義できない(型をつけることができない)ので、再帰関数も定義できない(のだろうと僕は思っている)し、もちろん副作用も使えない。
問題については、
1番の推移則(transirion)、2・3番の分配則(distribution,rev_distribution)、4番の排中律もどき(pseudo_excluded_middle1,pseudo_excluded_middle2)は再帰も副作用も例外処理もなしで実装できた。
再帰を使うと無限ループを作ることによって'a->'bという方を持つ式が作れてしまうので、型を指定してやれば何でもできてしまう。
したがって、5番の矛盾(contradiction)も無理やり作ることはできた。
また、これは実質的には不条理則に対応しており、6番のpeirceの法則もどき(pseudo_pierce)では'a->'bを作り出すためにこれを使った。
6番はもっといい方法があったのかもしれないが、どうしてもわからなかったので、2重否定除去より弱い不条理則で作った。
false_tの型を別の方法で定義していたら(もしくはいまの定義のままでうまく使えていたら)、可能なのかもしれない。

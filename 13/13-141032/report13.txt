関数・論理型プログラミング演習第13回レポート
氏名:八尋渉
学籍番号:05-141032

問1
ソースコード: SearchT.hs TreeSearch.hs
実行例: 
> let tr = SOr (SOr SNone (SUnit 1)) (SUnit 2) in dfs tr
Just 1
> let tr = SOr (SOr SNone (SUnit 1)) (SUnit 2) in bfs tr
Just 2
> let tr = SOr (SOr SNone (SUnit 1)) (SUnit 2) in iddfs tr
Just 2
*TreeSearches> let inft = SOr inft (SUnit 1) in dfs inft
^CInterrupted.
*TreeSearches> let inft = SOr inft (SUnit 1) in bfs inft
Just 1
*TreeSearches> let inft = SOr inft (SUnit 1) in iddfs inft
Just 1
考察:
haskellでDFSとBFSと反復深化による探索を実装した。
DFSは無限木では、止まらなくなった。

問2
ソースコード: SearchT.hs NatLists.hs
実行例:
> take 100 nat_lists
[[],[0],[1],[0,0],[2],[1,0],[0,1],[3],[0,0,0],[2,0],[1,1],[0,2],[4],[1,0,0],[0,1,0],[3,0],[0,0,1],[2,1],[1,2],[0,3],[5],[0,0,0,0],[2,0,0],[1,1,0],[0,2,0],[4,0],[1,0,1],[0,1,1],[3,1],[0,0,2],[2,2],[1,3],[0,4],[6],[1,0,0,0],[0,1,0,0],[3,0,0],[0,0,1,0],[2,1,0],[1,2,0],[0,3,0],[5,0],[0,0,0,1],[2,0,1],[1,1,1],[0,2,1],[4,1],[1,0,2],[0,1,2],[3,2],[0,0,3],[2,3],[1,4],[0,5],[7],[0,0,0,0,0],[2,0,0,0],[1,1,0,0],[0,2,0,0],[4,0,0],[1,0,1,0],[0,1,1,0],[3,1,0],[0,0,2,0],[2,2,0],[1,3,0],[0,4,0],[6,0],[1,0,0,1],[0,1,0,1],[3,0,1],[0,0,1,1],[2,1,1],[1,2,1],[0,3,1],[5,1],[0,0,0,2],[2,0,2],[1,1,2],[0,2,2],[4,2],[1,0,3],[0,1,3],[3,3],[0,0,4],[2,4],[1,5],[0,6],[8],[1,0,0,0,0],[0,1,0,0,0],[3,0,0,0],[0,0,1,0,0],[2,1,0,0],[1,2,0,0],[0,3,0,0],[5,0,0],[0,0,0,1,0],[2,0,1,0],[1,1,1,0]]
> take 100 nat_lists2
[[],[0],[0,0],[1],[0,0,0],[0,1],[1,0],[2],[0,0,0,0],[0,0,1],[0,1,0],[0,2],[1,0,0],[1,1],[2,0],[3],[0,0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,2],[0,1,0,0],[0,1,1],[0,2,0],[0,3],[1,0,0,0],[1,0,1],[1,1,0],[1,2],[2,0,0],[2,1],[3,0],[4],[0,0,0,0,0,0],[0,0,0,0,1],[0,0,0,1,0],[0,0,0,2],[0,0,1,0,0],[0,0,1,1],[0,0,2,0],[0,0,3],[0,1,0,0,0],[0,1,0,1],[0,1,1,0],[0,1,2],[0,2,0,0],[0,2,1],[0,3,0],[0,4],[1,0,0,0,0],[1,0,0,1],[1,0,1,0],[1,0,2],[1,1,0,0],[1,1,1],[1,2,0],[1,3],[2,0,0,0],[2,0,1],[2,1,0],[2,2],[3,0,0],[3,1],[4,0],[5],[0,0,0,0,0,0,0],[0,0,0,0,0,1],[0,0,0,0,1,0],[0,0,0,0,2],[0,0,0,1,0,0],[0,0,0,1,1],[0,0,0,2,0],[0,0,0,3],[0,0,1,0,0,0],[0,0,1,0,1],[0,0,1,1,0],[0,0,1,2],[0,0,2,0,0],[0,0,2,1],[0,0,3,0],[0,0,4],[0,1,0,0,0,0],[0,1,0,0,1],[0,1,0,1,0],[0,1,0,2],[0,1,1,0,0],[0,1,1,1],[0,1,2,0],[0,1,3],[0,2,0,0,0],[0,2,0,1],[0,2,1,0],[0,2,2],[0,3,0,0],[0,3,1],[0,4,0],[0,5],[1,0,0,0,0,0],[1,0,0,0,1],[1,0,0,1,0],[1,0,0,2]]
> elem [6,1,3,0,2,1] nat_lists
True
> elem [6,1,3,0,2,1] nat_lists2
True
考察:
nat_list_treeは、リストをうけとり、それを末尾に持つすべてのリストを要素に持つSearchTを返す関数。
nat_listsは、nat_list_treeに[]を与えた木を幅優先探索してリストにする。
一方nat_lists2は探索木を使用せずに実装した。
内部関数goは、自然数nを受け取り、「リストの長さ+全要素の和」がnに等しいすべてのリストを返す。

問3
ソースコード: Robo.hs
実行例:
> let ps = dijkstra  f1 plus (4, 3) in putStr (showField f1 ps ++ show ps ++ "\n")
____________x_______
_______*****x_______
_______*x__*x_g_____
____****x__*x_*_____
________x__****_____
_______xxxx_________
____________________
____________________
____________________
____________________
[(4,3),(5,3),(6,3),(7,3),(7,2),(7,1),(8,1),(9,1),(10,1),(11,1),(11,2),(11,3),(11,4),(12,4),(13,4),(14,4),(14,3),(14,2)]
> let ps = a_star  f1 plus (4, 3) in putStr (showField f1 ps ++ show ps ++ "\n")
____________x_______
_______***__x_______
____****x***x*g_____
____*___x__*x*______
________x__***______
_______xxxx_________
____________________
____________________
____________________
____________________
[(4,3),(4,2),(5,2),(6,2),(7,2),(7,1),(8,1),(9,1),(9,2),(10,2),(11,2),(11,3),(11,4),(12,4),(13,4),(13,3),(13,2),(14,2)]
> let ps = dijkstra  f2 plus (4, 5) in putStr (showField f2 ps ++ show ps ++ "\n")
____________________
_____________xxx____
________xxxxxxgx____
________x_____*_____
________x_____*_____
____****x_____*_____
_______*x_____*_____
_______********_____
____________________
____________________
[(4,5),(5,5),(6,5),(7,5),(7,6),(7,7),(8,7),(9,7),(10,7),(11,7),(12,7),(13,7),(14,7),(14,6),(14,5),(14,4),(14,3),(14,2)]
> let ps = a_star f2 plus (4, 5) in putStr (showField f2 ps ++ show ps ++ "\n")
____________________
_____________xxx____
________xxxxxxgx____
________x******_____
________x*__________
____****x*__________
_______*x*__________
_______***__________
____________________
____________________
[(4,5),(5,5),(6,5),(7,5),(7,6),(7,7),(8,7),(9,7),(9,6),(9,5),(9,4),(9,3),(10,3),(11,3),(12,3),(13,3),(14,3),(14,2)]
> let ps = dijkstra  f3 plus (0, 0) in putStr (showField f3 ps ++ show ps ++ "\n")
__x
_x_
x_g
[]
考察:
ダイクストラ法とA*でロボットの探索を実装した。
ロボットが動く領域はField型で表現し、サイズとゴールの位置と障害物の位置を保持する。
ロボットはRobot型で表現し、runNextはFieldと座標を与えると、次に移動可能な座標のリストを返し、runHeuristicで現在位置からゴールまでの距離の見積もりを計算できるようにした。

問4
ソースコード: Robo.hs
実行例:
*Robo> let ps = a_star f1 king (4, 3) in putStr (showField f1 ps ++ show ps ++ "\n")
_______*____x_______
______*_*___x_______
_____*__x*__x_g_____
____*___x_*_x*______
________x__**_______
_______xxxx_________
____________________
____________________
____________________
____________________
[(4,3),(5,2),(6,1),(7,0),(8,1),(9,2),(10,3),(11,4),(12,4),(13,3),(14,2)]
*Robo> let ps = dijkstra  f1 king (4, 3) in putStr (showField f1 ps ++ show ps ++ "\n")
____________x_______
________**__x_______
_______*x_*_x_g_____
____***_x__*x*______
________x___*_______
_______xxxx_________
____________________
____________________
____________________
____________________
[(4,3),(5,3),(6,3),(7,2),(8,1),(9,1),(10,2),(11,3),(12,4),(13,3),(14,2)]
*Robo> let ps = dijkstra f1 kinght (4, 3) in putStr (showField f1 ps ++ show ps ++ "\n")
____________x_______
____________x_______
________x___x_g_____
____*___x___x_______
______*_x____*______
_______xxxx_________
_______*____*_______
_________*__________
___________*________
____________________
[(4,3),(6,4),(7,6),(9,7),(11,8),(12,6),(13,4),(14,2)]
> let ps = a_star f1 kinght (4, 3) in putStr (showField f1 ps ++ show ps ++ "\n")
__________*_x__*____
________*___x*______
______*_x__*x_g_____
____*___x___x_______
________x___________
_______xxxx_________
____________________
____________________
____________________
____________________
[(4,3),(6,2),(8,1),(10,0),(11,2),(13,1),(15,0),(14,2)]
考察:
上下左右と斜めの8方向に移動できるkingと、8方向の桂馬飛び出移動するkinghtを作って、問3と同様に探索を行った。
kingは斜めにも移動できるため障害物がない場合は「max(x座標の差の絶対値,y座標の差の絶対値)」がゴールまでの距離となるので、それをヒューリスティック関数とし、
kinghtは見積もりが難しいので、3歩ずつ進むものとみなしてヒューリスティック関数は大体上下左右の時のものを3で割ったものとした。

問4
ソースコード: なし
実行例: なし
考察:
優先度が同じだった場合には、もう一回別の関数で優先度を計算しなおして、どちらを先に探索するか決めれば良い。
例えば、問のように王将の動きをさせる場合は、ヒューリスティック関数は「max(x座標の差の絶対値,y座標の差の絶対値)」のようになるが、それで優先度が同じだった場合は、上下左右しか動けない場合と同じ「x座標の差の絶対値+y座標の差の絶対値」を用いて比較すると、大きく迂回して(いるように見える)道を取ることはなくなるはずである。

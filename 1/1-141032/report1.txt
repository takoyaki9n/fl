関数・論理型プログラミング演習第1回レポート
氏名:八尋渉
学籍番号:05-141032

問1
ソースコード: q1_1.ml
実行例:
test_q1_1.mlを参照。

問2
ソースコード: q1_2.ml
実行例:
test_q1_2.mlを参照。
考察:
 fib1では、フィボナッチ数の定義通り内部で2回自身を呼び出している。
fib1 nを実行した時にfib1が呼び出される回数をA(n)とすると,
A(0)=A(1)=1
A(n)=A(n-1)+A(n-2)+1
(+1は自身の呼び出し分)
なので、n番目のフィボナッチ数+1となる。
フィボナッチ数の一般項はnの指数のオーダーなので、fib1 nの呼び出し回数もnの指数のオーダーで増えてゆく。
 一方fib2は内部で一度しか自身を呼び出していないので、呼び出し回数はnに対し線形のオーダーでしか増加しない。

問3
ソースコード: q1_3.ml
実行例:
test_q1_3.mlを参照。

問4
ソースコード: q1_4.ml
実行例:
test_q1_3.mlを参照。
考察:
fixは不動点関数であり、fixにうまく高階関数を与えると、その不動点となるような関数が得られる。
具体的には、再帰関数があったらそれを関数を引数に取る高階関数として定義しなおし、再帰呼び出し部分を引数としてとった関数で置き換えたものをfixに与えると、元の再帰関数と同等の関数が得られる。

問5
ソースコード: q1_5.ml
実行例:
test_q1_5.mlを参照。
考察:
それぞれの動作を丁寧に追うと以下のようになる。
fold_right f [x1; x2] e
= f x1 (fold_right f [x2] e)
= f x1 (f x2 (fold_right f [] e))
= f x1 (f x2 e)
fold_left f e [x1; x2]
= fold_left f (f e x1) [x2]
= fold_left f (f (f e x1) x2) []
= f (f e x1) x2
fold_leftは末尾再帰の形になっている。

問6
ソースコード: q1_6.ml
実行例:
test_q1_6.mlを参照。
考察:
appendとmapはほぼ同じ形、lastは末尾再帰で書いた。
なお、lastの返り値でoption型を使っているのは、
http://ocaml.org/learn/tutorials/99problems.html
を参考にしたからである。

問7
ソースコード: q1_7.ml
実行例:
test_q1_7.mlを参照。
考察:
リストの長さに対して線形時間で動作させるために末尾再帰で書いてある。

問8
ソースコード: q1_8.ml
実行例:
test_q1_8.mlを参照。
考察:
@を使っていいとは書いてあるが、appendlの内部で@を使うのは本末転倒な気がするのでこれでいいのか自信がない。
appendとmapはfold_rightのほうが簡単に書ける。fold_leftを使った方は@を使用しているので、動作が遅い。
逆にlastはfold_leftのほうが簡単に書けた。fold_rightを使った方も、最後の要素を取ってくるだけなら他の再帰関数を使わなくてよかったので、線形時間で動作する。
末尾再帰で書きやすいものはfold_left、そうでないものはfold_rightが書きやすいという事なのだろうか。

問9
ソースコード: q1_9.ml
実行例:
test_q1_9.mlを参照。
考察:
pick_one_listはリストを与えると、それからひとつの要素を除いたリストと除かれた要素の組のリストを返す関数である。
そして、ひとつの要素が除かれたリストについて再帰的に順列を求める。
その結果と除かれた要素をつなげて、更に平坦化して返すことですべての順列を列挙できる。

発展1
ソースコード: e1_1.ml
実行例:
test_e1_1.mlを参照。
考察:
fold_leftは「行きがけ」に、fold_rightは「帰りがけ」に関数を適用していく。
そのため、「帰りがけ」に「行きがけ」の操作をすることを考えた(ちょっと説明がわかりにくいかもしれないが)。
メイン部分の動作は、fold_rightに渡す関数をfと書くと以下のようになる。
fold_right f [x1; x2] ([x1; x2], [])
= f x1 (fold_right f [x2] ([x1; x2], []))
= f (x1 (f x2 (fold_right f [] ([x1; x2], [])))
= f (x1 (f x2 ([x1; x2], [])))
= f (x1 ([x2], [x1]))
= ([], [x2; x1])

発展2
ソースコード: e1_2.ml
実行例:
test_e1_2.mlを参照。
考察:
fold_rightに対してリスト[x1; x2]を逆順にしたものと、
f a b = f' b a
を満たすような関数f'を与えると、
fold_right f' [x2; x1] e
= f' x2 (fold_right f' [x1] e)
= f' x2 (f' x1 (fold_right f' [] e))
= f' x2 (f' x1 e
= f (f e x1) x2
= fold_left f e [x1; x2]
のように、fold_leftを使ったのと同じ結果が得られる。
同様にfold_leftに対しても
fold_left f' e [x2; x1]
= fold_left f' (f' e x2) [x1]
= fold_left f' (f' (f' e x2) x1) []
= f' (f' e x2) x1
= f x1 (f x2 e)
= fold_right f [x1; x2] e
となる。
以上により、逆順のリストを作ることが出来れば、fold_leftでfold_rightを作ることも、その逆も可能となる。
fold_leftでは自然に逆順のリストを作ることができるのでそのまま使えばよいが、fold_rightでは発展1のような工夫が必要になる。
これを使えば、問8も@を使わない形に書きなおすことができる。
